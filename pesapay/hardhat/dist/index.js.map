{"version":3,"file":"index.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/DA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://pesapay/./autotasks/relay/index.js","webpack://pesapay/./src/forwarder.js","webpack://pesapay/external commonjs2 \"defender-relay-client/lib/ethers\"","webpack://pesapay/external commonjs2 \"ethers\"","webpack://pesapay/webpack/bootstrap","webpack://pesapay/webpack/before-startup","webpack://pesapay/webpack/startup","webpack://pesapay/webpack/after-startup"],"sourcesContent":["const ethers = require(\"ethers\")\r\n// const Flutterwave = require(\"flutterwave-node-v3\")\r\nconst {\r\n  DefenderRelaySigner,\r\n  DefenderRelayProvider,\r\n} = require(\"defender-relay-client/lib/ethers\")\r\n\r\nconst { ForwarderAbi } = require(\"../../src/forwarder\")\r\nconst ForwarderAddress = require(\"../../deployCashout.json\").MinimalForwarder\r\nconst { FLW_PUBLIC_KEY: publicKey, FLW_SECRET_KEY: secretKey } = process.env\r\nconst flw = new Flutterwave(publicKey, secretKey)\r\n\r\nasync function relay(forwarder, request, signature, params, whitelist) {\r\n  // Decide if we want to relay this request based on a whitelist\r\n  const accepts = !whitelist || whitelist.includes(request.to)\r\n  if (!accepts) throw new Error(`Rejected request to ${request.to}`)\r\n\r\n  // Validate request on the forwarder contract\r\n  const valid = await forwarder.verify(request, signature)\r\n  if (!valid) throw new Error(`Invalid request`)\r\n\r\n  // Send meta-tx through relayer to the forwarder contract\r\n  const gasLimit = (parseInt(request.gas) + 50000).toString()\r\n  const tx = await forwarder.execute(request, signature, { gasLimit })\r\n  const reciept = await tx.wait(10)\r\n  // include logic to query the cashout contract matching the exact transaction has for events emited or for the ERC20 transfers.\r\n  try {\r\n    const { data } = await flw.Transfer.initiate(params)\r\n    console.log(data)\r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n  console.log(reciept)\r\n  return reciept\r\n}\r\n\r\nasync function handler(event) {\r\n  // Parse webhook payload\r\n  if (!event.request || !event.request.body) throw new Error(`Missing payload`)\r\n  const { request, signature, params } = event.request.body\r\n  console.log(`Relaying`, request, signature)\r\n\r\n  // Initialize Relayer provider and signer, and forwarder contract\r\n  const credentials = { ...event }\r\n  const provider = new DefenderRelayProvider(credentials)\r\n  const signer = new DefenderRelaySigner(credentials, provider, {\r\n    speed: \"fast\",\r\n  })\r\n  const forwarder = new ethers.Contract(ForwarderAddress, ForwarderAbi, signer)\r\n\r\n  // Relay transaction!\r\n  const tx = await relay(forwarder, request, signature, params)\r\n  console.log(`Sent meta-tx: ${tx.confirmations}`)\r\n  return { txHash: tx.confirmations }\r\n}\r\n\r\nmodule.exports = {\r\n  handler,\r\n  relay,\r\n}\r\n","/**\r\n * ABI of the MinimalForwarder contract\r\n */\r\nconst ForwarderAbi = [\r\n  { inputs: [], stateMutability: \"nonpayable\", type: \"constructor\" },\r\n  {\r\n    inputs: [\r\n      {\r\n        components: [\r\n          { internalType: \"address\", name: \"from\", type: \"address\" },\r\n          { internalType: \"address\", name: \"to\", type: \"address\" },\r\n          { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\r\n          { internalType: \"uint256\", name: \"gas\", type: \"uint256\" },\r\n          { internalType: \"uint256\", name: \"nonce\", type: \"uint256\" },\r\n          { internalType: \"bytes\", name: \"data\", type: \"bytes\" },\r\n        ],\r\n        internalType: \"struct MinimalForwarder.ForwardRequest\",\r\n        name: \"req\",\r\n        type: \"tuple\",\r\n      },\r\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\r\n    ],\r\n    name: \"execute\",\r\n    outputs: [\r\n      { internalType: \"bool\", name: \"\", type: \"bool\" },\r\n      { internalType: \"bytes\", name: \"\", type: \"bytes\" },\r\n    ],\r\n    stateMutability: \"payable\",\r\n    type: \"function\",\r\n  },\r\n  {\r\n    inputs: [{ internalType: \"address\", name: \"from\", type: \"address\" }],\r\n    name: \"getNonce\",\r\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\r\n    stateMutability: \"view\",\r\n    type: \"function\",\r\n  },\r\n  {\r\n    inputs: [\r\n      {\r\n        components: [\r\n          { internalType: \"address\", name: \"from\", type: \"address\" },\r\n          { internalType: \"address\", name: \"to\", type: \"address\" },\r\n          { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\r\n          { internalType: \"uint256\", name: \"gas\", type: \"uint256\" },\r\n          { internalType: \"uint256\", name: \"nonce\", type: \"uint256\" },\r\n          { internalType: \"bytes\", name: \"data\", type: \"bytes\" },\r\n        ],\r\n        internalType: \"struct MinimalForwarder.ForwardRequest\",\r\n        name: \"req\",\r\n        type: \"tuple\",\r\n      },\r\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\r\n    ],\r\n    name: \"verify\",\r\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\r\n    stateMutability: \"view\",\r\n    type: \"function\",\r\n  },\r\n]\r\n\r\nmodule.exports = {\r\n  ForwarderAbi,\r\n}\r\n","module.exports = require(\"defender-relay-client/lib/ethers\");","module.exports = require(\"ethers\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./autotasks/relay/index.js\");\n",""],"names":[],"sourceRoot":""}