"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useStyleConfig = useStyleConfig;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = require("react");

var _glamor = require("glamor");

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _reactFastCompare = _interopRequireDefault(require("react-fast-compare"));

var _uiBox = require("ui-box");

var _theme = require("../theme");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {object} StateStyles
 * @property {import('csstype').Properties} [_hover]
 * @property {import('csstype').Properties} [_active]
 * @property {import('csstype').Properties} [_disabled]
 * @property {import('csstype').Properties} [_focus]
 * @property {import('csstype').Properties} [_invalid]
 */

/**
 * @typedef {{ [placeholder in keyof StateStyles]: string }} PseudoSelectors
 */

/**
 * @typedef {object} StyleModifiers
 * @property {string} [appearance]
 * @property {string} [size]
 */

/** @typedef {import('ui-box').EnhancerProps & StateStyles} Style */

/** @typedef {import('ui-box').EnhancerProps & import('glamor').CSSProperties} GlamorAndBoxStyle */

/**
 * @typedef {object} StyleConfig
 * @property {Style} baseStyle
 * @property {{ [appearance: string]: Style }} [appearances]
 * @property {{ [size: string]: Style }} [sizes]
 */
function maybeRun(value) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return typeof value === 'function' ? value.apply(void 0, args) : value;
}

function maybeRunDeep(raw) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (raw && (0, _typeof2["default"])(raw) === 'object') {
    var result = {};

    for (var _i = 0, _Object$keys = Object.keys(raw); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      result[key] = maybeRunDeep.apply(void 0, [raw[key]].concat(args));
    }

    return result;
  }

  return maybeRun.apply(void 0, [raw].concat(args));
}
/**
 * Combines styles from a styleConfig, with the given style modifiers (appearance, size, etc) and internal styles
 * @param {object} theme
 * @param {StyleModifiers} props
 * @param {StyleConfig} styleConfig
 * @param {GlamorAndBoxStyle} [internalStyles]
 * @returns {StyleConfig}
 */


function combineStyles(theme, props, styleConfig) {
  var internalStyles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var config = maybeRun(styleConfig, theme, props);
  var baseStyle = maybeRunDeep(config.baseStyle, theme, props);
  var sizeStyle = maybeRunDeep((0, _theme.get)(config, "sizes.".concat(props.size), {}), theme, props);
  var appearanceStyle = maybeRunDeep((0, _theme.get)(config, "appearances.".concat(props.appearance), {}), theme, props);
  return (0, _lodash["default"])({}, internalStyles, baseStyle, sizeStyle, appearanceStyle);
}
/**
 * Combines a styleConfig object with internal styles based on the theme + style modifiers (props)
 * and returns a memoized style object
 * @returns {StyleConfig}
 */


function useMergedStyles(theme, props, styleConfig, internalStyles) {
  var styleRef = (0, _react.useRef)({});
  return (0, _react.useMemo)(function () {
    var combinedStyles = combineStyles(theme, props, styleConfig, internalStyles);

    if (!(0, _reactFastCompare["default"])(styleRef.current, combinedStyles)) {
      styleRef.current = combinedStyles;
    }

    return styleRef.current;
  }, [theme, props, styleConfig, internalStyles]);
}
/**
 * Split up the style props into glamor-ready and box-ready props (className + spreadable props)
 */


function useGlamorAndBox(styles, pseudoSelectors) {
  var glamorStylesRef = (0, _react.useRef)({});
  var classNameRef = (0, _react.useRef)();
  return (0, _react.useMemo)(function () {
    // Split the resulting style object into ui-box-compatible props and the rest
    var _splitBoxProps = (0, _uiBox.splitBoxProps)(styles),
        matchedProps = _splitBoxProps.matchedProps,
        remainingProps = _splitBoxProps.remainingProps;
    /** @type {GlamorAndBoxStyle} */


    var glamorStyles = {}; // Swap out pseudo selector placeholders for their actual css selector strings

    for (var _i2 = 0, _Object$keys2 = Object.keys(remainingProps); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      var key = k in pseudoSelectors ? pseudoSelectors[k] : k;
      glamorStyles[key] = remainingProps[k];
    } // Take all the "non-compatible" props and give those to glamor (since ui-box doesn't know how to handle them yet)


    if (!(0, _reactFastCompare["default"])(glamorStylesRef.current, glamorStyles)) {
      var className = (0, _glamor.css)(glamorStyles).toString();
      glamorStylesRef.current = glamorStyles;
      classNameRef.current = className === 'css-nil' ? undefined : className;
    }

    return _objectSpread({
      className: classNameRef.current
    }, matchedProps);
  }, [styles, pseudoSelectors]);
}
/**
 * Takes a styleConfig object and outputs a `className` and `boxProps` that can be spread on a Box component
 * @param {string} componentKey the name of the component in the theme
 * @param {StyleModifiers} props props that modify the resulting visual style (e.g. `size` or `appearance`)
 * @param {PseudoSelectors} pseudoSelectors mapping for the component between states and actual pseudo selectors
 * @param {GlamorAndBoxStyle} [internalStyles] additional styles that are specified internally, separate from the visual styles
 * @returns {{ className: string; boxProps: import('ui-box').EnhancerProps }}
 */


function useStyleConfig(componentKey, props, pseudoSelectors, internalStyles) {
  var theme = (0, _theme.useTheme)(); // Get the component style object from the theme

  var componentStyles = (0, _theme.get)(theme, "components.".concat(componentKey)) || {}; // Merges the theme styles with the modifiers/props (appearance, size, etc)

  var mergedStyles = useMergedStyles(theme, props, componentStyles, internalStyles); // Resolve theme token strings found throughout the style object

  var styles = (0, _react.useMemo)(function () {
    return (0, _theme.resolveThemeTokens)(theme, mergedStyles);
  }, [theme, mergedStyles]); // Finally, split up the styles based which ones Box supports and the rest construct a glamor className

  return useGlamorAndBox(styles, pseudoSelectors);
}