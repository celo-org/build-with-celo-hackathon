"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _react2 = require("@testing-library/react");

var _userEvent = _interopRequireDefault(require("@testing-library/user-event"));

var _ = require("../");

var _utils = require("../../test/utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function makeTextInputFixture() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return /*#__PURE__*/_react["default"].createElement(_.TextInput, (0, _extends2["default"])({
    "data-testid": "input"
  }, props));
}

makeTextInputFixture.displayName = "makeTextInputFixture";

function makeTextInputFieldFixture() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return /*#__PURE__*/_react["default"].createElement(_.TextInputField, (0, _extends2["default"])({
    "data-testid": "input",
    label: "Name"
  }, props));
}

makeTextInputFieldFixture.displayName = "makeTextInputFieldFixture";
describe('TextInput', function () {
  it('should forward ref to underlying <input />', function () {
    var ref = (0, _utils.mockRef)();
    (0, _react2.render)(makeTextInputFixture({
      ref: ref
    }));
    expect(ref.current).toBeInstanceOf(HTMLInputElement);
  });
  it('should render without crashing', function () {
    expect(function () {
      return (0, _react2.render)(makeTextInputFixture());
    }).not.toThrow();
  });
  it('should accept placeholder text', function () {
    var _render = (0, _react2.render)(makeTextInputFixture({
      placeholder: 'Enter text here'
    })),
        getByPlaceholderText = _render.getByPlaceholderText;

    expect(getByPlaceholderText('Enter text here')).toBeInTheDocument();
  });
  it('should set an invalid state if `isInvalid` is `true`', function () {
    var _render2 = (0, _react2.render)(makeTextInputFixture({
      isInvalid: true
    })),
        getByTestId = _render2.getByTestId;

    var input = getByTestId('input');
    expect(input).toHaveAttribute('aria-invalid', 'true');
  });
  it('should accept an `onChange` handler to be a controlled component', function () {
    function ControlledTextInput() {
      var _useState = (0, _react.useState)(''),
          _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
          value = _useState2[0],
          setValue = _useState2[1];

      return /*#__PURE__*/_react["default"].createElement(_.TextInput, {
        "data-testid": "input",
        placeholder: "Enter text here",
        value: value,
        onChange: function onChange(e) {
          return setValue(e.target.value);
        }
      });
    }

    var _render3 = (0, _react2.render)( /*#__PURE__*/_react["default"].createElement(ControlledTextInput, null)),
        getByDisplayValue = _render3.getByDisplayValue,
        getByTestId = _render3.getByTestId;

    var input = getByTestId('input');

    _userEvent["default"].click(input);

    expect(document.activeElement).toEqual(input);

    _userEvent["default"].type(input, 'Testing');

    expect(getByDisplayValue('Testing')).toEqual(input);
  });
  it('should not be interactive if `disabled` is passed in', function () {
    var _render4 = (0, _react2.render)(makeTextInputFixture({
      disabled: true
    })),
        getByDisplayValue = _render4.getByDisplayValue,
        getByTestId = _render4.getByTestId;

    var input = getByTestId('input');

    _userEvent["default"].type(input, 'Testing');

    expect(function () {
      return getByDisplayValue('Testing');
    }).toThrowError();
    expect(getByDisplayValue('')).toEqual(input);
  });
});
describe('TextInputField', function () {
  it('Should render without crashing', function () {
    expect(function () {
      return (0, _react2.render)(makeTextInputFieldFixture());
    }).not.toThrow();
  });
  it('Should have expected accessible name when `label` prop', function () {
    var _render5 = (0, _react2.render)(makeTextInputFieldFixture()),
        getByLabelText = _render5.getByLabelText,
        getByTestId = _render5.getByTestId;

    expect(getByLabelText('Name')).toBeInTheDocument();
    expect(getByTestId('input')).toHaveAccessibleName('Name');
  });
  it('Should add hint text to accessible description when `hint` prop provided', function () {
    var _render6 = (0, _react2.render)(makeTextInputFieldFixture({
      hint: 'Enter a value in the input'
    })),
        getByTestId = _render6.getByTestId,
        getByText = _render6.getByText;

    expect(getByText('Enter a value in the input')).toBeInTheDocument();
    expect(getByTestId('input')).toHaveAccessibleDescription('Enter a value in the input');
  });
  it('Should render an astrix when `required` is passed in', function () {
    var _render7 = (0, _react2.render)(makeTextInputFieldFixture({
      required: true
    })),
        getByTitle = _render7.getByTitle;

    expect(getByTitle('This field is required.')).toBeInTheDocument();
  });
  it('Should render a `validationMessage` when passed in', function () {
    var _render8 = (0, _react2.render)(makeTextInputFieldFixture({
      validationMessage: 'Please enter a value.'
    })),
        getByTestId = _render8.getByTestId,
        getByText = _render8.getByText;

    expect(getByText('Please enter a value.')).toBeInTheDocument();
    expect(getByTestId('input')).toHaveAccessibleDescription('Please enter a value.');
  });
  it('Should correctly compose an accessible description from multiple hints', function () {
    var _render9 = (0, _react2.render)(makeTextInputFieldFixture({
      description: 'A description.',
      hint: 'Am hint.',
      validationMessage: 'Try again.'
    })),
        getByTestId = _render9.getByTestId,
        getByText = _render9.getByText;

    expect(getByText('A description.')).toBeInTheDocument();
    expect(getByText('Am hint.')).toBeInTheDocument();
    expect(getByText('Try again.')).toBeInTheDocument();
    expect(getByTestId('input')).toHaveAccessibleDescription('A description. Try again. Am hint.');
  });
});