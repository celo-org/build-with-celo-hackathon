"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = _interopRequireDefault(require("lodash.omit"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _uiBox = _interopRequireDefault(require("ui-box"));

var _autocomplete = require("../../autocomplete");

var _buttons = require("../../buttons");

var _hooks = require("../../hooks");

var _icons = require("../../icons");

var _safeInvoke = _interopRequireDefault(require("../../lib/safe-invoke"));

var _scales = require("../../scales");

var _textInput = require("../../text-input");

var _Tag = _interopRequireDefault(require("./Tag"));

var _excluded = ["addOnBlur", "disabled", "height", "separator", "values", "tagSubmitKey", "tagProps", "onAdd", "onChange", "onRemove", "onBlur", "onFocus", "onInputChange", "className", "inputProps", "inputRef", "isInvalid", "autocompleteItems"],
    _excluded2 = ["className"],
    _excluded3 = ["onBlur", "onChange", "onKeyDown"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var GET_KEY_FOR_TAG_DELIMITER = {
  enter: 'Enter',
  space: ' '
};
var emptyProps = {};
var emptyArray = [];
var internalStyles = {
  alignItems: 'center',
  display: 'inline-flex',
  flexWrap: 'wrap',
  position: 'relative'
};
var pseudoSelectors = {
  _focused: '&[aria-activedescendant]',
  _disabled: '&[aria-disabled="true"]',
  _invalid: '&[aria-invalid="true"]:not(:focus)'
};
var TagInput = /*#__PURE__*/(0, _react.memo)( /*#__PURE__*/(0, _react.forwardRef)(function TagInput(props, ref) {
  var _props$addOnBlur = props.addOnBlur,
      addOnBlur = _props$addOnBlur === void 0 ? false : _props$addOnBlur,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$height = props.height,
      height = _props$height === void 0 ? 32 : _props$height,
      _props$separator = props.separator,
      separator = _props$separator === void 0 ? /[,\n\r]/ : _props$separator,
      _props$values = props.values,
      values = _props$values === void 0 ? emptyArray : _props$values,
      _props$tagSubmitKey = props.tagSubmitKey,
      tagSubmitKey = _props$tagSubmitKey === void 0 ? 'enter' : _props$tagSubmitKey,
      _props$tagProps = props.tagProps,
      tagProps = _props$tagProps === void 0 ? emptyProps : _props$tagProps,
      onAdd = props.onAdd,
      onChange = props.onChange,
      onRemove = props.onRemove,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      onInputChange = props.onInputChange,
      className = props.className,
      _props$inputProps = props.inputProps,
      inputProps = _props$inputProps === void 0 ? emptyProps : _props$inputProps,
      inputRef = props.inputRef,
      isInvalid = props.isInvalid,
      autocompleteItems = props.autocompleteItems,
      rest = (0, _objectWithoutProperties2["default"])(props, _excluded);

  var _useState = (0, _react.useState)(''),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      inputValue = _useState2[0],
      setInputValue = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      isFocused = _useState4[0],
      setIsFocused = _useState4[1];

  var id = (0, _hooks.useId)('TagInput');
  var autocompleteId = "TagInputAutocomplete-".concat(values.length);
  var inputId = inputProps && inputProps.id ? inputProps.id : id;
  var hasAutocomplete = Array.isArray(autocompleteItems) && autocompleteItems.length > 0;

  var getValues = function getValues() {
    var inputValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    inputValue = inputValue || '';
    return separator ? inputValue.split(separator).map(function (v) {
      return v.trim();
    }).filter(function (v) {
      return v.length > 0;
    }) : [inputValue];
  };

  var addTags = function addTags() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var newValues = getValues(value);
    var shouldClearInput = (0, _safeInvoke["default"])(onAdd, newValues);

    if (typeof onChange === 'function') {
      shouldClearInput = shouldClearInput || onChange(values.concat(newValues));
    }

    if (shouldClearInput !== false) {
      setInputValue('');
    }
  };

  var removeTagAtIndex = function removeTagAtIndex(index) {
    (0, _safeInvoke["default"])(onRemove, values[index], index); // Remove item at index as a new array

    var newValues = values.filter(function (_, i) {
      return i !== index;
    });
    (0, _safeInvoke["default"])(onChange, newValues);
  };

  var handleBackspaceToRemove = function handleBackspaceToRemove() {
    removeTagAtIndex(values.length - 1);
  };

  var handleBlur = function handleBlur(event) {
    var container = event.target;
    requestAnimationFrame(function () {
      if (!container.contains(document.activeElement)) {
        if (addOnBlur && inputValue) {
          addTags(inputValue);
          setInputValue('');
        }

        setIsFocused(false);
      }
    });
    (0, _safeInvoke["default"])(onBlur, event);
  };

  var handleInputChange = function handleInputChange(event) {
    setInputValue(event.target.value);
    (0, _safeInvoke["default"])(onInputChange, event);
  };

  var handleInputFocus = function handleInputFocus(event) {
    setIsFocused(true);
    (0, _safeInvoke["default"])(onFocus, event);
  };

  var handleKeyDown = function handleKeyDown(event) {
    var _event$target = event.target,
        selectionEnd = _event$target.selectionEnd,
        value = _event$target.value;
    var key = GET_KEY_FOR_TAG_DELIMITER[tagSubmitKey];

    if (event.key === key) {
      event.preventDefault();
      addTags(value);
    } else if (event.key === 'Backspace' && selectionEnd === 0) {
      handleBackspaceToRemove(event);
    }
  };

  var handleRemoveTag = function handleRemoveTag(event) {
    // Using data attribute to simplify callback logic -- one handler for all children
    var index = Number(event.currentTarget.parentElement.getAttribute('data-tag-index'));
    removeTagAtIndex(index);
  };

  var maybeRenderTag = function maybeRenderTag(tag, index) {
    if (!tag) {
      return null;
    }

    var propsForElement = (0, _safeInvoke["default"])(tagProps, tag, index) || tagProps;
    return /*#__PURE__*/_react["default"].createElement(_Tag["default"], (0, _extends2["default"])({
      key: "".concat(tag, ":").concat(index),
      "data-tag-index": index,
      marginX: (0, _scales.majorScale)(1),
      marginY: (0, _scales.minorScale)(1) * 1.5,
      onRemove: disabled ? null : handleRemoveTag,
      isRemovable: !disabled
    }, propsForElement), tag);
  };

  var _useStyleConfig = (0, _hooks.useStyleConfig)('TagInput', {
    appearance: 'default',
    height: height
  }, pseudoSelectors, internalStyles),
      themedContainerClassName = _useStyleConfig.className,
      boxProps = (0, _objectWithoutProperties2["default"])(_useStyleConfig, _excluded2);

  return /*#__PURE__*/_react["default"].createElement(_uiBox["default"], (0, _extends2["default"])({
    "aria-disabled": disabled || undefined,
    "aria-activedescendant": isFocused ? inputId : undefined,
    "aria-invalid": isInvalid,
    className: (0, _classnames["default"])(themedContainerClassName, className),
    ref: ref,
    onBlur: handleBlur
  }, boxProps, rest, {
    paddingRight: hasAutocomplete ? (0, _scales.majorScale)(3) : undefined
  }), /*#__PURE__*/_react["default"].createElement(_uiBox["default"], {
    flexGrow: "1",
    display: "inline-block"
  }, /*#__PURE__*/_react["default"].createElement(_autocomplete.Autocomplete, {
    onChange: function onChange(changedItem) {
      addTags(changedItem);
      setInputValue('');
    },
    items: hasAutocomplete ? autocompleteItems : [],
    id: autocompleteId,
    selectedItem: "",
    inputValue: inputValue
  }, function (autocompleteProps) {
    var closeMenu = autocompleteProps.closeMenu,
        getInputProps = autocompleteProps.getInputProps,
        autocompleteGetRef = autocompleteProps.getRef,
        getToggleButtonProps = autocompleteProps.getToggleButtonProps,
        highlightedIndex = autocompleteProps.highlightedIndex;

    var _getInputProps = getInputProps(),
        autocompleteOnBlur = _getInputProps.onBlur,
        autocompleteOnChange = _getInputProps.onChange,
        autocompleteKeyDown = _getInputProps.onKeyDown,
        autocompleteRestProps = (0, _objectWithoutProperties2["default"])(_getInputProps, _excluded3);

    var handleAutocompleteKeydown = function handleAutocompleteKeydown(e) {
      autocompleteKeyDown(e);

      if (e.key === 'Backspace' || !(highlightedIndex > -1)) {
        handleKeyDown(e);

        if (e.key === GET_KEY_FOR_TAG_DELIMITER[tagSubmitKey]) {
          closeMenu();
          setInputValue('');
        }
      }

      if (e.key === 'Backspace' && e.target.selectionEnd === 0) {
        closeMenu();
      }
    };

    return /*#__PURE__*/_react["default"].createElement(_uiBox["default"], {
      display: "flex",
      ref: function ref(boxInputRef) {
        autocompleteGetRef(boxInputRef);
      },
      flexWrap: "wrap",
      width: inputProps.width
    }, values.map(maybeRenderTag), /*#__PURE__*/_react["default"].createElement(_textInput.TextInput, (0, _extends2["default"])({
      appearance: "none",
      disabled: disabled,
      height: height - 4,
      flexGrow: "1",
      type: "text"
    }, (0, _lodash["default"])(inputProps, ['width']), autocompleteRestProps, {
      value: inputValue,
      id: inputId,
      ref: function ref(textInputRef) {
        if (inputRef instanceof Function) {
          inputRef(textInputRef);
        } else if (inputRef) {
          inputRef.current = textInputRef;
        }
      },
      onBlur: function onBlur(e) {
        autocompleteOnBlur(e);
        (0, _safeInvoke["default"])(inputProps.onBlur, e);
      },
      onFocus: function onFocus(e) {
        handleInputFocus(e);
        (0, _safeInvoke["default"])(inputProps.onFocus, e);
      },
      onChange: function onChange(e) {
        handleInputChange(e);
        autocompleteOnChange(e);
      },
      onKeyDown: handleAutocompleteKeydown
    })), hasAutocomplete && /*#__PURE__*/_react["default"].createElement(_buttons.Button, (0, _extends2["default"])({
      appearance: "none",
      background: "gray100",
      position: "absolute",
      top: (0, _scales.minorScale)(1) * 1.5,
      right: (0, _scales.minorScale)(1),
      height: (0, _scales.minorScale)(5),
      padding: 0,
      width: (0, _scales.minorScale)(5),
      minWidth: (0, _scales.minorScale)(5),
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: (0, _scales.minorScale)(1),
      cursor: disabled ? undefined : 'pointer',
      "data-testid": "TagInput-autocomplete-toggle"
    }, getToggleButtonProps()), /*#__PURE__*/_react["default"].createElement(_icons.CaretDownIcon, {
      color: "muted"
    })));
  })));
}));
TagInput.propTypes = {
  /** Whether or not the inputValue should be added to the tags when the input blurs. */
  addOnBlur: _propTypes["default"].bool,

  /** Autocomplete options to show when typing in a new value */
  autocompleteItems: _propTypes["default"].array,

  /** The class name to apply to the container component. */
  className: _propTypes["default"].string,

  /** Whether or not the input should be disabled. */
  disabled: _propTypes["default"].bool,

  /** Whether or not the input is invalid. */
  isInvalid: _propTypes["default"].bool,

  /** The vertical size of the input */
  height: _propTypes["default"].number,

  /** Props to pass to the input component. Note that `ref` and `key` are not supported. See `inputRef`. */
  inputProps: _propTypes["default"].object,

  /**
   * Ref handler for the input element.
   * (input: HTMLInputElement | null) => void
   */
  inputRef: _propTypes["default"].func,

  /**
   * Callback invoked when new tags are added.
   * Returning `false` will prevent clearing the input.
   * (values: Array) => void | false
   */
  onAdd: _propTypes["default"].func,

  /**
   * Callback invoked when focus on the input blurs.
   * (event) => void
   */
  onBlur: _propTypes["default"].func,

  /**
   * Callback invoked when the tag values change.
   * Returning `false` will prevent clearing the input.
   * (values: Array) => void | false
   */
  onChange: _propTypes["default"].func,

  /**
   * Callback invoked when the input receives focus.
   * (event) => void
   */
  onFocus: _propTypes["default"].func,

  /**
   * Callback invoked when the value of the input is changed. Shorthand for `inputProps={{ onChange }}`.
   * (event) => void
   */
  onInputChange: _propTypes["default"].func,

  /**
   * Callback invoked when a tag is removed.
   * Receives value and index of removed tag.
   * (value: string | node, index: number) => void
   */
  onRemove: _propTypes["default"].func,

  /** Value or RegExp to split on pasted text or on enter keypress */
  separator: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].instanceOf(RegExp), _propTypes["default"].oneOf([false])]),

  /** Provide props to tag component (actually `Badge`, for now). */
  tagProps: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]),

  /** Key to press in order to submit a new tag while typing.  */
  tagSubmitKey: _propTypes["default"].oneOf(['enter', 'space']),

  /** Controlled tag values. Each value is rendered inside a tag. */
  values: _propTypes["default"].arrayOf(_propTypes["default"].node)
};
var _default = TagInput;
exports["default"] = _default;