"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _glamor = require("glamor");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactTransitionGroup = require("react-transition-group");

var _uiBox = _interopRequireDefault(require("ui-box"));

var _Alert = _interopRequireDefault(require("../../alert/src/Alert"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var animationEasing = {
  deceleration: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
  acceleration: 'cubic-bezier(0.4, 0.0, 1, 1)',
  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'
};
var ANIMATION_DURATION = 240;

var openAnimation = _glamor.css.keyframes('openAnimation', {
  from: {
    opacity: 0,
    transform: 'translateY(-120%)'
  },
  to: {
    transform: 'translateY(0)'
  }
});

var closeAnimation = _glamor.css.keyframes('closeAnimation', {
  from: {
    transform: 'scale(1)',
    opacity: 1
  },
  to: {
    transform: 'scale(0.9)',
    opacity: 0
  }
});

var animationStyles = (0, _glamor.css)({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  height: 0,
  transition: "all ".concat(ANIMATION_DURATION, "ms ").concat(animationEasing.deceleration),
  '&[data-state="entering"], &[data-state="entered"]': {
    animation: "".concat(openAnimation, " ").concat(ANIMATION_DURATION, "ms ").concat(animationEasing.spring, " both")
  },
  '&[data-state="exiting"]': {
    animation: "".concat(closeAnimation, " 120ms ").concat(animationEasing.acceleration, " both")
  }
});
var Toast = /*#__PURE__*/(0, _react.memo)(function Toast(props) {
  var children = props.children,
      duration = props.duration,
      hasCloseButton = props.hasCloseButton,
      _props$intent = props.intent,
      intent = _props$intent === void 0 ? 'none' : _props$intent,
      isShownProp = props.isShown,
      onRemove = props.onRemove,
      title = props.title,
      zIndex = props.zIndex;
  var transitionRef = (0, _react.useRef)(null);

  var _useState = (0, _react.useState)(true),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      isShown = _useState2[0],
      setIsShown = _useState2[1];

  var _useState3 = (0, _react.useState)(0),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      height = _useState4[0],
      setHeight = _useState4[1];

  var closeTimer = (0, _react.useRef)(null);
  var clearCloseTimer = (0, _react.useCallback)(function () {
    if (closeTimer.current) {
      clearTimeout(closeTimer.current);
      closeTimer.current = null;
    }
  }, []);
  var close = (0, _react.useCallback)(function () {
    clearCloseTimer();
    setIsShown(false);
  }, [clearCloseTimer]);
  var startCloseTimer = (0, _react.useCallback)(function () {
    if (duration) {
      clearCloseTimer();
      closeTimer.current = setTimeout(function () {
        close();
      }, duration * 1000);
    }
  }, [duration, clearCloseTimer, close]);
  (0, _react.useEffect)(function () {
    startCloseTimer();
    return function () {
      clearCloseTimer();
    };
  }, [startCloseTimer, clearCloseTimer]);
  (0, _react.useEffect)(function () {
    if (isShownProp !== isShown && typeof isShownProp === 'boolean') {
      setIsShown(isShownProp);
    }
  }, [isShown, isShownProp]);
  var handleMouseEnter = (0, _react.useCallback)(function () {
    return clearCloseTimer();
  }, [clearCloseTimer]);
  var handleMouseLeave = (0, _react.useCallback)(function () {
    return startCloseTimer();
  }, [startCloseTimer]);
  var onRef = (0, _react.useCallback)(function (ref) {
    if (ref === null) return;

    var _ref$getBoundingClien = ref.getBoundingClientRect(),
        rectHeight = _ref$getBoundingClien.height;

    setHeight(rectHeight);
  }, []);
  var styles = (0, _react.useMemo)(function () {
    return {
      height: height,
      zIndex: zIndex,
      marginBottom: isShown ? 0 : -height
    };
  }, [isShown, height, zIndex]);
  return /*#__PURE__*/_react["default"].createElement(_reactTransitionGroup.Transition, {
    nodeRef: transitionRef,
    appear: true,
    unmountOnExit: true,
    timeout: ANIMATION_DURATION,
    "in": isShown,
    onExited: onRemove
  }, function (state) {
    return /*#__PURE__*/_react["default"].createElement("div", {
      ref: transitionRef,
      "data-state": state,
      className: animationStyles,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      style: styles
    }, /*#__PURE__*/_react["default"].createElement(_uiBox["default"], {
      ref: onRef,
      padding: 8
    }, /*#__PURE__*/_react["default"].createElement(_Alert["default"], {
      flexShrink: 0,
      appearance: "card",
      elevation: 3,
      intent: intent,
      title: title,
      isRemoveable: hasCloseButton,
      onRemove: close,
      pointerEvents: "all"
    }, children)));
  });
});
Toast.propTypes = {
  /**
   * The z-index of the toast.
   */
  zIndex: _propTypes["default"].number,

  /**
   * Duration of the toast.
   */
  duration: _propTypes["default"].number,

  /**
   * Function called when the toast is all the way closed.
   */
  onRemove: _propTypes["default"].func,

  /**
   * The type of the alert.
   */
  intent: _propTypes["default"].string,

  /**
   * The title of the alert.
   */
  title: _propTypes["default"].node,

  /**
   * Description of the alert.
   */
  children: _propTypes["default"].node,

  /**
   * When true, show a close icon button inside of the toast.
   */
  hasCloseButton: _propTypes["default"].bool,

  /**
   * When false, will close the Toast and call onRemove when finished.
   */
  isShown: _propTypes["default"].bool
};
var _default = Toast;
exports["default"] = _default;