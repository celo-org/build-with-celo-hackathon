"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _hooks = require("../../hooks");

var _textarea = require("../../textarea");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function getTableBodyRef(currentRef) {
  var ref = currentRef;
  if (!ref) return;

  while (ref) {
    var isTableBody = ref.hasAttribute('data-evergreen-table-body');

    if (isTableBody) {
      return ref;
    }

    if (ref.parentElement) {
      ref = ref.parentElement;
    } else {
      return null;
    }
  }

  return ref;
}

var EditableCellField = /*#__PURE__*/(0, _react.memo)(function EditableCellField(props) {
  var _props$minHeight = props.minHeight,
      minHeight = _props$minHeight === void 0 ? 40 : _props$minHeight,
      _props$minWidth = props.minWidth,
      minWidth = _props$minWidth === void 0 ? 80 : _props$minWidth,
      size = props.size,
      value = props.value,
      zIndex = props.zIndex;
  var latestAnimationFrame = (0, _react.useRef)();
  var textareaRef = (0, _react.useRef)();
  var tableBodyRef = (0, _react.useRef)();
  var onCancelRef = (0, _hooks.useLatest)(props.onCancel);
  var onChangeCompleteRef = (0, _hooks.useLatest)(props.onChangeComplete);
  var getTargetRef = (0, _hooks.useLatest)(props.getTargetRef);

  var _useState = (0, _react.useState)(0),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      height = _useState2[0],
      setHeight = _useState2[1];

  var _useState3 = (0, _react.useState)(0),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      width = _useState4[0],
      setWidth = _useState4[1];

  var _useState5 = (0, _react.useState)(0),
      _useState6 = (0, _slicedToArray2["default"])(_useState5, 2),
      left = _useState6[0],
      setLeft = _useState6[1];

  var _useState7 = (0, _react.useState)(0),
      _useState8 = (0, _slicedToArray2["default"])(_useState7, 2),
      top = _useState8[0],
      setTop = _useState8[1];

  var update = (0, _react.useCallback)(function () {
    function updater() {
      var targetRef = getTargetRef.current();
      if (!targetRef) return;
      tableBodyRef.current = getTableBodyRef(targetRef);

      var _targetRef$getBoundin = targetRef.getBoundingClientRect(),
          targetHeight = _targetRef$getBoundin.height,
          targetLeft = _targetRef$getBoundin.left,
          targetTop = _targetRef$getBoundin.top,
          targetWidth = _targetRef$getBoundin.width;

      var calculatedTop;

      if (tableBodyRef.current) {
        var bounds = tableBodyRef.current.getBoundingClientRect();
        calculatedTop = Math.min(Math.max(targetTop, bounds.top), bounds.bottom - targetHeight);
      } else {
        calculatedTop = targetTop;
      }

      setHeight(targetHeight);
      setWidth(targetWidth);
      setLeft(targetLeft);
      setTop(calculatedTop); // recursively run the updater

      latestAnimationFrame.current = requestAnimationFrame(function () {
        return updater();
      });
    } // kick off the updater


    updater(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Mirrors functionality of componentDidMount and componentWillUnmount.
  // Focus on mount

  (0, _react.useLayoutEffect)(function () {
    update();
    var requestId = requestAnimationFrame(function () {
      if (textareaRef.current) {
        textareaRef.current.focus();
      }
    });
    return function () {
      cancelAnimationFrame(requestId);

      if (latestAnimationFrame.current) {
        cancelAnimationFrame(latestAnimationFrame.current);
      } // eslint-disable-next-line react-hooks/exhaustive-deps


      onCancelRef.current();
    }; // we only want `update` to run once, and `onCancelRef` is a ref
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  var handleFocus = (0, _react.useCallback)(function (e) {
    e.target.selectionStart = e.target.value.length;
  }, []);
  var handleBlur = (0, _react.useCallback)(function () {
    if (textareaRef.current) {
      onChangeCompleteRef.current(textareaRef.current.value);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  var handleKeyDown = (0, _react.useCallback)(function (e) {
    switch (e.key) {
      case 'Escape':
        onCancelRef.current();
        if (textareaRef.current) textareaRef.current.blur();
        break;

      case 'Enter':
        if (textareaRef.current) textareaRef.current.blur();
        e.preventDefault();
        break;

      case 'Tab':
        if (textareaRef.current) textareaRef.current.blur();
        break;

      default:
        break;
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  var style = (0, _react.useMemo)(function () {
    return {
      left: left,
      top: top,
      height: height,
      minHeight: Math.max(height, minHeight),
      width: width,
      minWidth: Math.max(width, minWidth),
      zIndex: zIndex
    };
  }, [left, top, height, width, minHeight, minWidth, zIndex]);
  return /*#__PURE__*/_react["default"].createElement(_textarea.Textarea, {
    ref: textareaRef,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur,
    onFocus: handleFocus,
    appearance: "editable-cell",
    size: size,
    style: style,
    height: null,
    width: null,
    minHeight: null,
    position: "fixed",
    defaultValue: value
  });
});
EditableCellField.propTypes = {
  /**
   * Used as the defaultValue of the textarea.
   */
  value: _propTypes["default"].string.isRequired,

  /**
   * The z-index placed on the element.
   */
  zIndex: _propTypes["default"].number.isRequired,

  /**
   * Function to get the target ref of the parent.
   * Used to mirror the position.
   */
  getTargetRef: _propTypes["default"].func.isRequired,

  /**
   * Min width of the textarea.
   * The textarea can never be smaller than the cell.
   */
  minWidth: _propTypes["default"].number,

  /**
   * Min height of the textarea.
   * The textarea can never be smaller than the cell.
   */
  minHeight: _propTypes["default"].number,

  /**
   * Called when the textarea is blurred, pass the value back to the cell.
   */
  onChangeComplete: _propTypes["default"].func.isRequired,

  /**
   * Called when Escape is hit or componentWillUnmount.
   */
  onCancel: _propTypes["default"].func.isRequired,

  /**
   * Text size of the textarea.
   */
  size: _propTypes["default"].number
};
var _default = EditableCellField;
exports["default"] = _default;