"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _lodash = _interopRequireDefault(require("lodash.isempty"));

var _lodash2 = _interopRequireDefault(require("lodash.uniqby"));

var _FileRejectionReason = _interopRequireDefault(require("../../../constants/src/FileRejectionReason"));

var _hasValue = _interopRequireDefault(require("../../../lib/has-value"));

var _messages = require("./messages");

/**
 * @typedef {object} FileRejection
 * @property {File} file
 * @property {string} message Informative message to display to the user for why the file was rejected
 * @property {string} reason Error code/enum to denote why the file was rejected
 */

/**
 * Returns a list of objects containing rejected files and why they were rejected based on the provided options
 * @param {File[]} files
 * @param {import('./split-files').SplitFilesOptions | undefined} options
 * @returns {FileRejection[]}
 */
var getFileRejections = function getFileRejections(files, options) {
  if (options == null || (0, _lodash["default"])(files)) {
    return [];
  }

  var acceptedMimeTypes = options.acceptedMimeTypes,
      currentCount = options.currentFileCount,
      maxFiles = options.maxFiles,
      maxSizeInBytes = options.maxSizeInBytes;
  var typeRejections = files.map(function (file) {
    if ((0, _lodash["default"])(acceptedMimeTypes) || acceptedMimeTypes !== null && acceptedMimeTypes !== void 0 && acceptedMimeTypes.some(function (type) {
      return file.type === type;
    })) {
      return;
    }

    return {
      file: file,
      reason: _FileRejectionReason["default"].InvalidFileType,
      message: "This file is not an accepted format. ".concat((0, _messages.getAcceptedTypesMessage)(acceptedMimeTypes))
    };
  });
  var sizeRejections = files.map(function (file) {
    if (maxSizeInBytes == null || maxSizeInBytes === 0 || file.size <= maxSizeInBytes) {
      return;
    }

    return {
      file: file,
      reason: _FileRejectionReason["default"].FileTooLarge,
      message: "This file is too big. ".concat((0, _messages.getFileSizeMessage)(maxSizeInBytes))
    };
  });
  var countRejections = files.map(function (file, index) {
    if (maxFiles == null) {
      return;
    }

    var fileNumber = index + 1;

    if ((currentCount !== null && currentCount !== void 0 ? currentCount : 0) + fileNumber <= maxFiles) {
      return;
    }

    return {
      file: file,
      reason: _FileRejectionReason["default"].OverFileLimit,
      message: (0, _messages.getMaxFilesMessage)(maxFiles)
    };
  }); // Type rejections are arguably more important than size rejections, so those will take priority

  var fileRejections = [].concat((0, _toConsumableArray2["default"])(typeRejections), (0, _toConsumableArray2["default"])(sizeRejections), (0, _toConsumableArray2["default"])(countRejections)).filter(_hasValue["default"]);
  return (0, _lodash2["default"])(fileRejections, function (rejection) {
    return rejection.file;
  });
};

var _default = getFileRejections;
exports["default"] = _default;