"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _glamor = require("glamor");

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _constants = require("../../constants");

var _hooks = require("../../hooks");

var _positioner = require("../../positioner");

var _TooltipStateless = _interopRequireDefault(require("./TooltipStateless"));

var _excluded = ["getTargetRef", "isShown"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var emptyProps = {};
var Tooltip = /*#__PURE__*/(0, _react.memo)(function Tooltip(props) {
  var _props$appearance = props.appearance,
      appearance = _props$appearance === void 0 ? 'default' : _props$appearance,
      _props$position = props.position,
      position = _props$position === void 0 ? _constants.Position.BOTTOM : _props$position,
      content = props.content,
      _props$hideDelay = props.hideDelay,
      hideDelay = _props$hideDelay === void 0 ? 120 : _props$hideDelay,
      _props$showDelay = props.showDelay,
      showDelay = _props$showDelay === void 0 ? 0 : _props$showDelay,
      propIsShown = props.isShown,
      children = props.children,
      _props$statelessProps = props.statelessProps,
      statelessProps = _props$statelessProps === void 0 ? emptyProps : _props$statelessProps;
  var id = (0, _hooks.useId)('evergreen-tooltip');

  var _useState = (0, _react.useState)(propIsShown || false),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      isShown = _useState2[0],
      setIsShown = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      isShownByTarget = _useState4[0],
      setIsShownByTarget = _useState4[1];

  var closeTimer = (0, _react.useRef)(undefined);

  var mouseLeftTarget = function mouseLeftTarget() {
    setIsShownByTarget(false);
  };

  var handleMouseLeaveTarget = (0, _lodash["default"])(mouseLeftTarget, hideDelay);

  var hide = function hide() {
    setIsShown(false); // Clean up any timeouts that may have been triggered from `showDelay`

    clearTimeout(closeTimer.current);
  };

  var handleHide = (0, _lodash["default"])(hide, hideDelay); // Component will unmount

  (0, _react.useEffect)(function () {
    return function () {
      clearTimeout(closeTimer.current);
    };
  }, []);

  var show = function show() {
    if (isShown) return;

    if (!showDelay) {
      setIsShown(true);
      return;
    }

    clearTimeout(closeTimer.current);
    closeTimer.current = setTimeout(function () {
      setIsShown(true);
    }, showDelay);
  };

  var renderTarget = function renderTarget(_ref) {
    var getRef = _ref.getRef;
    var tooltipTargetProps = {
      onMouseEnter: show,
      onMouseLeave: handleHide,
      'aria-describedby': id
    };
    /**
     * Tooltips can be used within a Popover (not the other way around)
     * When a Tooltip is used within a Popover, the Popover passes
     * its props to the Tooltip in a `popoverProps` object.
     */
    // eslint-disable-next-line react/prop-types

    if (props.popoverProps) {
      var _props$popoverProps = props.popoverProps,
          getTargetRef = _props$popoverProps.getTargetRef,
          _isShown = _props$popoverProps.isShown,
          popoverTargetProps = (0, _objectWithoutProperties2["default"])(_props$popoverProps, _excluded);
      return /*#__PURE__*/_react["default"].cloneElement(children, _objectSpread(_objectSpread(_objectSpread({}, popoverTargetProps), tooltipTargetProps), {}, {
        ref: function ref(_ref2) {
          // Get the ref for the Tooltip.
          getRef(_ref2); // Pass the ref to the Popover.

          getTargetRef(_ref2);
        }
      }));
    }
    /**
     * With normal usage only the props for a Tooltip are passed to the target.
     */


    return /*#__PURE__*/_react["default"].cloneElement(children, _objectSpread(_objectSpread({}, tooltipTargetProps), {}, {
      ref: function ref(_ref3) {
        getRef(_ref3);
      }
    }));
  }; // eslint-disable-next-line react/prop-types


  var isPopoverShown = function isPopoverShown() {
    return props.popoverProps && props.popoverProps.isShown;
  };

  var handleMouseEnterTarget = function handleMouseEnterTarget() {
    setIsShownByTarget(true);
  };

  var shown = (propIsShown || isShown || isShownByTarget) && !isPopoverShown(); // Tooltip was explicitly set to not be shown

  if (propIsShown === false) {
    shown = false;
  }

  return /*#__PURE__*/_react["default"].createElement(_positioner.Positioner, {
    target: renderTarget,
    isShown: shown,
    position: position,
    animationDuration: 160
  }, function (_ref4) {
    var css = _ref4.css,
        getRef = _ref4.getRef,
        state = _ref4.state,
        style = _ref4.style;
    return /*#__PURE__*/_react["default"].createElement(_TooltipStateless["default"], (0, _extends2["default"])({
      id: id,
      appearance: appearance,
      ref: getRef,
      "data-state": state,
      style: style,
      onMouseEnter: handleMouseEnterTarget,
      onMouseLeave: handleMouseLeaveTarget
    }, statelessProps, {
      className: (0, _classnames["default"])(statelessProps.className, css ? (0, _glamor.css)(css).toString() : undefined)
    }), content);
  });
});
Tooltip.propTypes = {
  /**
   * The appearance of the tooltip.
   */
  appearance: _propTypes["default"].oneOf(['default', 'card']),

  /**
   * The position the Popover is on.
   */
  position: _propTypes["default"].oneOf([_constants.Position.TOP, _constants.Position.TOP_LEFT, _constants.Position.TOP_RIGHT, _constants.Position.BOTTOM, _constants.Position.BOTTOM_LEFT, _constants.Position.BOTTOM_RIGHT, _constants.Position.LEFT, _constants.Position.RIGHT]),

  /**
   * The content of the Popover.
   */
  content: _propTypes["default"].node,

  /**
   * Time in ms before hiding the Tooltip.
   */
  hideDelay: _propTypes["default"].number,

  /**
   * Time in ms before showing the Tooltip.
   */
  showDelay: _propTypes["default"].number,

  /**
   * Controls whether the Tooltip is shown or not.
   * - When `true`, the component is always shown, regardless of the whether the target is hovered.
   * - When `false`, the component is never shown, regardless of the whether the target is hovered.
   * - When `undefined`, the component is uncontrolled and the isShown state is handled internally
   * (i.e. the Tooltip is shown when the target is hovered)
   */
  isShown: _propTypes["default"].bool,

  /**
   * The target button of the Tooltip.
   */
  children: _propTypes["default"].node,

  /**
   * Properties passed through to the Tooltip.
   */
  statelessProps: _propTypes["default"].object
};
var _default = Tooltip;
exports["default"] = _default;