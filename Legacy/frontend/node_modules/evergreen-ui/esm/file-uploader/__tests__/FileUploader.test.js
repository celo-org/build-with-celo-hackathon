import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import React from 'react';
import { faker } from '@faker-js/faker';
import { render, screen, fireEvent, cleanup } from '@testing-library/react';
import { Key, MimeType } from '../../constants';
import { buildFiles } from '../../test/utils';
import FileUploader from '../src/FileUploader';
var testId = 'test-file-uploader';
/**
 * Utility function for rendering the system under test with a props object + testing id
 * @param {import('../../..').FileUploaderProps} props
 */

var renderWithProps = function renderWithProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return render( /*#__PURE__*/React.createElement(FileUploader, _extends({}, props, {
    "data-testid": testId
  })));
};

describe('FileUploader', function () {
  beforeEach(cleanup);
  describe('props', function () {
    describe('acceptedMimeTypes', function () {
      it('should forward csv string to file input', function () {
        var acceptedMimeTypes = faker.random.arrayElements(Object.values(MimeType));
        renderWithProps({
          acceptedMimeTypes: acceptedMimeTypes
        });
        var fileUploader = screen.getByTestId(testId);
        var fileInput = fileUploader.querySelector('input');
        expect(fileInput).toHaveAttribute('accept', acceptedMimeTypes.join(','));
      });
    });
    describe('description', function () {
      it('should render description', function () {
        var description = faker.random.words();
        renderWithProps({
          description: description
        });
        expect(screen.getByText(description)).toBeInTheDocument();
      });
    });
    describe('disabled', function () {
      it('should ignore click event when disabled', function () {
        var onClick = jest.fn();
        var disabled = true;
        renderWithProps({
          disabled: disabled
        });
        var fileUploader = screen.getByTestId(testId);
        var fileInput = fileUploader.querySelector('input');
        fileInput.onclick = onClick;
        fireEvent.click(fileUploader);
        expect(onClick).not.toHaveBeenCalled();
      });
      it.each([Key.Enter, Key.Space])('should ignore %p keyboard event when disabled', function (key) {
        var onClick = jest.fn();
        var disabled = true;
        renderWithProps({
          disabled: disabled
        });
        var fileUploader = screen.getByTestId(testId);
        var fileInput = fileUploader.querySelector('input');
        fileInput.onclick = onClick;
        fireEvent.keyDown(fileUploader, {
          key: key
        });
        expect(onClick).not.toHaveBeenCalled();
      });
      it('should set aria-disabled true', function () {
        var disabled = true;
        renderWithProps({
          disabled: disabled
        });
        var fileUploader = screen.getByTestId(testId);
        expect(fileUploader).toHaveAttribute('aria-disabled', true.toString());
      });
    });
    describe('hint', function () {
      it('should render hint', function () {
        var hint = faker.random.words();
        renderWithProps({
          hint: hint
        });
        expect(screen.getByText(hint)).toBeInTheDocument();
      });
    });
    describe('label', function () {
      it('should render label', function () {
        var label = faker.random.words();
        renderWithProps({
          label: label
        });
        expect(screen.getByText(label)).toBeInTheDocument();
      });
    });
    describe('maxFiles', function () {
      it("should render singular 'file' when maxFiles is 1", function () {
        var maxFiles = 1;
        renderWithProps({
          maxFiles: maxFiles
        });
        expect(screen.getByText(function (text) {
          return text.includes('file') && !text.includes('files');
        })).toBeInTheDocument();
      });
      it.each([undefined, null, 0, 2, 100])("should render plural 'files' when maxFiles is %p", function (maxFiles) {
        renderWithProps({
          maxFiles: maxFiles
        });
        expect(screen.getByText(function (text) {
          return text.includes('files');
        })).toBeInTheDocument();
      });
      it('should not render dropzone when maxFiles is 1 and values is not empty', function () {
        var values = buildFiles(1);
        var maxFiles = 1;
        renderWithProps({
          maxFiles: maxFiles,
          values: values
        });
        expect(screen.queryByTestId(testId)).toBeNull();
      });
    });
    describe('onAccepted', function () {
      describe('when files should be accepted', function () {
        it('should fire on drop', function () {
          var onAccepted = jest.fn();
          var files = buildFiles(3);
          renderWithProps({
            onAccepted: onAccepted
          });
          var fileUploader = screen.getByTestId(testId);
          fireEvent.drop(fileUploader, {
            dataTransfer: {
              files: files
            }
          });
          expect(onAccepted).toHaveBeenCalledWith(files);
        });
        it('should fire when file input receives files', function () {
          var onAccepted = jest.fn();
          var files = buildFiles(3);
          renderWithProps({
            onAccepted: onAccepted
          });
          var fileUploader = screen.getByTestId(testId);
          var fileInput = fileUploader.querySelector('input');
          fireEvent.change(fileInput, {
            target: {
              files: files
            }
          });
          expect(onAccepted).toHaveBeenCalledWith(files);
        });
      });
      describe('when files should be rejected', function () {
        it('should not fire', function () {
          var onAccepted = jest.fn();
          var maxSizeInBytes = faker.datatype.number({
            min: 1024,
            max: 10 * 1024
          });
          var files = buildFiles(3, {
            size: maxSizeInBytes + 1
          });
          renderWithProps({
            maxSizeInBytes: maxSizeInBytes,
            onAccepted: onAccepted
          });
          var fileUploader = screen.getByTestId(testId);
          var fileInput = fileUploader.querySelector('input');
          fireEvent.change(fileInput, {
            target: {
              files: files
            }
          });
          expect(onAccepted).not.toHaveBeenCalled();
        });
      });
    });
    describe('onChange', function () {
      it('should fire on drop', function () {
        var onChange = jest.fn();
        var files = buildFiles(3);
        renderWithProps({
          onChange: onChange
        });
        var fileUploader = screen.getByTestId(testId);
        fireEvent.drop(fileUploader, {
          dataTransfer: {
            files: files
          }
        });
        expect(onChange).toHaveBeenCalledWith(files);
      });
      it('should fire when file input receives files', function () {
        var onChange = jest.fn();
        var files = buildFiles(3);
        renderWithProps({
          onChange: onChange
        });
        var fileUploader = screen.getByTestId(testId);
        var fileInput = fileUploader.querySelector('input');
        fireEvent.change(fileInput, {
          target: {
            files: files
          }
        });
        expect(onChange).toHaveBeenCalledWith(files);
      });
      it('should include both accepted and rejected files in callback ', function () {
        var onChange = jest.fn();
        var maxSizeInBytes = faker.datatype.number({
          min: 1024,
          max: 10 * 1024
        });
        var acceptedFiles = buildFiles(3, {
          size: maxSizeInBytes - 1
        });
        var rejectedFiles = buildFiles(3, {
          size: maxSizeInBytes + 1
        });
        var expected = [].concat(_toConsumableArray(acceptedFiles), _toConsumableArray(rejectedFiles));
        renderWithProps({
          maxSizeInBytes: maxSizeInBytes,
          onChange: onChange
        });
        var fileUploader = screen.getByTestId(testId);
        fireEvent.drop(fileUploader, {
          dataTransfer: {
            files: expected
          }
        });
        expect(onChange).toHaveBeenCalledWith(expected);
      });
      describe('should fire even if array is empty', function () {
        var onChange = jest.fn();
        var expected = [];
        renderWithProps({
          onChange: onChange
        });
        var fileUploader = screen.getByTestId(testId);
        fireEvent.drop(fileUploader, {
          dataTransfer: {
            files: expected
          }
        });
        expect(onChange).toHaveBeenCalledWith(expected);
      });
      describe('when disabled is true', function () {
        it('should not fire on drop', function () {
          var disabled = true;
          var onChange = jest.fn();
          var files = buildFiles(3);
          renderWithProps({
            disabled: disabled,
            onChange: onChange
          });
          var fileUploader = screen.getByTestId(testId);
          fireEvent.drop(fileUploader, {
            dataTransfer: {
              files: files
            }
          });
          expect(onChange).not.toHaveBeenCalled();
        });
        it('should not fire when file input receives files', function () {
          var disabled = true;
          var onChange = jest.fn();
          var files = buildFiles(3);
          renderWithProps({
            disabled: disabled,
            onChange: onChange
          });
          var fileUploader = screen.getByTestId(testId);
          var fileInput = fileUploader.querySelector('input');
          fireEvent.change(fileInput, {
            target: {
              files: files
            }
          });
          expect(onChange).not.toHaveBeenCalled();
        });
      });
    });
    describe('onRejected', function () {
      describe('when files should be accepted', function () {
        it('should not fire', function () {
          var onRejected = jest.fn();
          var maxSizeInBytes = faker.datatype.number({
            min: 1024,
            max: 10 * 1024
          });
          var files = buildFiles(3, {
            size: maxSizeInBytes - 1
          });
          renderWithProps({
            maxSizeInBytes: maxSizeInBytes,
            onRejected: onRejected
          });
          var fileUploader = screen.getByTestId(testId);
          var fileInput = fileUploader.querySelector('input');
          fireEvent.change(fileInput, {
            target: {
              files: files
            }
          });
          expect(onRejected).not.toHaveBeenCalled();
        });
      });
      describe('when files should be rejected', function () {
        it('should fire on drop', function () {
          var onRejected = jest.fn();
          var maxSizeInBytes = faker.datatype.number({
            min: 1024,
            max: 10 * 1024
          });
          var files = buildFiles(3, {
            size: maxSizeInBytes + 1
          });
          var expected = expect.arrayContaining(files.map(function (file) {
            return expect.objectContaining({
              file: file
            });
          }));
          renderWithProps({
            maxSizeInBytes: maxSizeInBytes,
            onRejected: onRejected
          });
          var fileUploader = screen.getByTestId(testId);
          fireEvent.drop(fileUploader, {
            dataTransfer: {
              files: files
            }
          });
          expect(onRejected).toHaveBeenCalledWith(expected);
        });
        it('should fire when file input receives files', function () {
          var onRejected = jest.fn();
          var maxSizeInBytes = faker.datatype.number({
            min: 1024,
            max: 10 * 1024
          });
          var files = buildFiles(3, {
            size: maxSizeInBytes + 1
          });
          var expected = expect.arrayContaining(files.map(function (file) {
            return expect.objectContaining({
              file: file
            });
          }));
          renderWithProps({
            maxSizeInBytes: maxSizeInBytes,
            onRejected: onRejected
          });
          var fileUploader = screen.getByTestId(testId);
          var fileInput = fileUploader.querySelector('input');
          fireEvent.change(fileInput, {
            target: {
              files: files
            }
          });
          expect(onRejected).toHaveBeenCalledWith(expected);
        });
      });
    });
    describe('renderFile', function () {
      it('should be called for each file', function () {
        var renderFile = jest.fn();
        var values = buildFiles(2);
        renderWithProps({
          renderFile: renderFile,
          values: values
        });
        expect(renderFile).toHaveBeenCalledTimes(values.length);
      });
    });
    describe('validationMessage', function () {
      it('should render validationMessage', function () {
        var validationMessage = faker.random.words();
        renderWithProps({
          validationMessage: validationMessage
        });
        expect(screen.getByText(validationMessage)).toBeInTheDocument();
      });
      it('should not render validationMessage when dragging invalid number of files', function () {
        var validationMessage = faker.random.words();
        var maxFiles = 2;

        var _renderWithProps = renderWithProps({
          maxFiles: maxFiles,
          validationMessage: validationMessage
        }),
            rerender = _renderWithProps.rerender;

        var fileUploader = screen.getByTestId(testId);
        fireEvent.dragOver(fileUploader, {
          dataTransfer: {
            files: buildFiles(maxFiles + 1)
          }
        });
        rerender();
        expect(screen.queryByText(validationMessage)).toBeNull();
      });
    });
    describe('values', function () {
      it('should render <FileCard /> for each file', function () {
        var values = buildFiles(2);
        renderWithProps({
          values: values
        });
        var fileCards = values.map(function (file) {
          return screen.getByText(file.name);
        }, {
          exact: true
        });
        expect(fileCards).toHaveLength(values.length);
      });
    });
  });
  describe('interactions', function () {
    describe('when clicked', function () {
      it('should forward click event to file input', function () {
        var onClick = jest.fn();
        renderWithProps();
        var fileUploader = screen.getByTestId(testId);
        var fileInput = fileUploader.querySelector('input');
        fileInput.onclick = onClick;
        fireEvent.click(fileUploader);
        expect(onClick).toHaveBeenCalled();
      });
    });
    describe('when keyboard event is fired', function () {
      it.each([Key.Enter, Key.Space])('should forward as click event to file input when key is %p', function (key) {
        var onClick = jest.fn();
        renderWithProps();
        var fileUploader = screen.getByTestId(testId);
        var fileInput = fileUploader.querySelector('input');
        fileInput.onclick = onClick;
        fireEvent.keyDown(fileUploader, {
          key: key
        });
        expect(onClick).toHaveBeenCalled();
      });
      it.each(['A', '[', '1'])('should ignore event when key is %p', function (key) {
        var onClick = jest.fn();
        renderWithProps();
        var fileUploader = screen.getByTestId(testId);
        var fileInput = fileUploader.querySelector('input');
        fileInput.onclick = onClick;
        fireEvent.keyDown(fileUploader, {
          key: key
        });
        expect(onClick).not.toHaveBeenCalled();
      });
    });
  });
});