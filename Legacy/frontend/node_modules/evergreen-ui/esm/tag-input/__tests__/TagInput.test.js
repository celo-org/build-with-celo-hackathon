import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import TagInput from '../src/TagInput';
var TEST_VALUES = ['one', 'two', 'three'];
var TEST_PLACEHOLDER = 'Enter something...';
describe('<TagInput />', function () {
  describe('onAdd', function () {
    it('should be called when a new value is entered', function () {
      var mockOnAdd = jest.fn();
      var newTestVal = 'Testing';
      render( /*#__PURE__*/React.createElement(TagInput, {
        values: TEST_VALUES,
        onAdd: mockOnAdd,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), "".concat(newTestVal, "{enter}"));
      expect(screen.queryByTestId('TagInput-autocomplete-toggle')).not.toBeInTheDocument();
      expect(mockOnAdd).toHaveBeenCalledWith([newTestVal]);
    });
  });
  describe('onRemove', function () {
    it('should be called after hitting backspace', function () {
      var mockOnRemove = jest.fn();
      render( /*#__PURE__*/React.createElement(TagInput, {
        values: TEST_VALUES,
        onRemove: mockOnRemove,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), '{backspace}');
      var lastValueIndex = TEST_VALUES.length - 1;
      expect(mockOnRemove).toHaveBeenCalledWith(TEST_VALUES[lastValueIndex], lastValueIndex);
    });
  });
  describe('onChange', function () {
    it('should be called when a value is added', function () {
      var mockOnChange = jest.fn();
      var newTestVal = 'Testing';
      render( /*#__PURE__*/React.createElement(TagInput, {
        values: TEST_VALUES,
        onChange: mockOnChange,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), "".concat(newTestVal, "{enter}"));
      expect(mockOnChange).toHaveBeenLastCalledWith(TEST_VALUES.concat([newTestVal]));
    });
    it('should be called when a value is removed', function () {
      var mockOnChange = jest.fn();
      render( /*#__PURE__*/React.createElement(TagInput, {
        values: TEST_VALUES,
        onChange: mockOnChange,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), '{backspace}');
      var valuesLastRemoved = TEST_VALUES.slice(0, -1);
      expect(mockOnChange).toHaveBeenLastCalledWith(valuesLastRemoved);
    });
  });
  describe('tagSubmitKey', function () {
    it('should allow entering values with space key', function () {
      var mockOnAdd = jest.fn();
      var newTestVal = 'Testing';
      render( /*#__PURE__*/React.createElement(TagInput, {
        tagSubmitKey: "space",
        values: TEST_VALUES,
        onAdd: mockOnAdd,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), "".concat(newTestVal, "{space}"));
      expect(mockOnAdd).toHaveBeenCalledWith([newTestVal]);
    });
  });
  describe('disabled', function () {
    it('prop should disable input', function () {
      render( /*#__PURE__*/React.createElement(TagInput, {
        disabled: true,
        values: TEST_VALUES,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      expect(screen.getByPlaceholderText(TEST_PLACEHOLDER)).toBeDisabled();
    });
    it('prop should remove X icons', function () {
      render( /*#__PURE__*/React.createElement(TagInput, {
        disabled: true,
        values: TEST_VALUES,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      TEST_VALUES.forEach(function (value) {
        // Checks to make sure the "X" icon is not within each tag
        expect(screen.getByText(value).children.length).toBe(0);
      });
    });
  });
  describe('addOnBlur', function () {
    it('should allow adding new value on blur', function () {
      var mockOnAdd = jest.fn();
      jest.spyOn(window, 'requestAnimationFrame').mockImplementation(function (cb) {
        return cb();
      });
      var newTestVal = 'Testing';
      render( /*#__PURE__*/React.createElement(TagInput, {
        addOnBlur: true,
        "data-testid": "wrapper",
        values: TEST_VALUES,
        onAdd: mockOnAdd,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), newTestVal);
      screen.getByPlaceholderText(TEST_PLACEHOLDER).blur();
      fireEvent.blur(screen.getByPlaceholderText(TEST_PLACEHOLDER));
      expect(mockOnAdd).toHaveBeenCalledWith([newTestVal]);
      window.requestAnimationFrame.mockRestore();
    });
  });
  describe('separator', function () {
    it('prop should allow entering multiple values at a time', function () {
      var mockOnAdd = jest.fn();
      var newTestVal = 'Testing|123';
      render( /*#__PURE__*/React.createElement(TagInput, {
        separator: "|",
        values: TEST_VALUES,
        onAdd: mockOnAdd,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), "".concat(newTestVal, "{enter}"));
      expect(mockOnAdd).toHaveBeenCalledWith(['Testing', '123']);
    });
  });
  describe('autocompleteItems', function () {
    it('should render a toggle button when provided', function () {
      var mockOnAdd = jest.fn();
      var testAutocompleteItems = ['Testing1', 'Testing2', 'Testing3', 'Other'];
      render( /*#__PURE__*/React.createElement(TagInput, {
        autocompleteItems: testAutocompleteItems,
        values: TEST_VALUES,
        onAdd: mockOnAdd,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      testAutocompleteItems.forEach(function (item) {
        expect(screen.queryByText(item)).not.toBeInTheDocument();
      });
      userEvent.click(screen.getByTestId('TagInput-autocomplete-toggle'));
      testAutocompleteItems.forEach(function (item) {
        expect(screen.queryByText(item)).toBeInTheDocument();
      });
    });
    it('should reveal options based on search query', function () {
      var mockOnAdd = jest.fn();
      var testAutocompleteItems = ['Testing1', 'Testing2', 'Testing3', 'Other'];
      var testSearch = 'Test';
      render( /*#__PURE__*/React.createElement(TagInput, {
        autocompleteItems: testAutocompleteItems,
        values: TEST_VALUES,
        onAdd: mockOnAdd,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      testAutocompleteItems.forEach(function (item) {
        expect(screen.queryByText(item)).not.toBeInTheDocument();
      });
      userEvent.type(screen.getByPlaceholderText(TEST_PLACEHOLDER), testSearch);
      testAutocompleteItems.forEach(function (item) {
        if (item.startsWith(testSearch)) {
          expect(screen.queryByText(item)).toBeInTheDocument();
        } else {
          expect(screen.queryByText(item)).not.toBeInTheDocument();
        }
      });
    });
    it('should allow user to add item via popover', function () {
      var mockOnAdd = jest.fn();
      var testAutocompleteItems = ['Testing1', 'Testing2', 'Testing3', 'Other'];
      render( /*#__PURE__*/React.createElement(TagInput, {
        autocompleteItems: testAutocompleteItems,
        values: TEST_VALUES,
        onAdd: mockOnAdd,
        inputProps: {
          placeholder: TEST_PLACEHOLDER
        }
      }));
      userEvent.click(screen.getByTestId('TagInput-autocomplete-toggle'));
      userEvent.click(screen.getByText(testAutocompleteItems[0]));
      expect(mockOnAdd).toHaveBeenCalledWith([testAutocompleteItems[0]]);
    });
  });
});